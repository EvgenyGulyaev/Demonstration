{"version":3,"sources":["config.js","api/index.js","components/App/styles.js","components/Image/index.js","components/App/index.js","serviceWorker.js","index.js"],"names":["url","config","getImages","acceptedFiles","a","data","FormData","append","axios","method","headers","res","console","log","ParentContainer","styled","div","ImageContainer","StyledImage","img","src","StyledImageContainer","text","StyledContent","Image","name","alt","onClick","defaultProps","App","useState","image","setImage","mask","setMask","dropRef","useRef","onDrop","useCallback","slice","map","file","Object","assign","preview","URL","createObjectURL","path","useDropzone","getRootProps","getInputProps","current","click","ref","Boolean","window","location","hostname","match","ReactDOM","render","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister"],"mappings":"uPAAe,EACR,4BCECA,EAAQC,EAEHC,EAAS,uCAAG,WAAOC,GAAP,mBAAAC,EAAA,uEAEfC,EAAO,IAAIC,UACZC,OAAO,QAASJ,EAAc,IAHd,SAIOK,IAAM,CAChCC,OAAQ,OACRT,MACAK,OACAJ,OAAQ,CAAES,QAAS,CAAE,eAAgB,0BARlB,uBAIPC,EAJO,EAIbN,KAJa,kBAUdM,GAVc,yCAarBC,QAAQC,IAAI,QAAZ,MAbqB,kBAcd,IAdc,0DAAH,sD,00BCHf,IAAMC,EAAkBC,IAAOC,IAAV,KAUfC,EAAiBF,IAAOC,IAAV,KAQdE,EAAcH,IAAOI,IAAV,KACX,qBAAEC,IAAe,EAAI,MACtB,qBAAEA,IAAe,OAAS,sBAQzBC,EAAuBN,IAAOC,IAAV,KAIf,kBAAqB,UAArB,EAAEM,KAA6B,OAAS,KAI7CC,EAAgBR,IAAOC,IAAV,KCnCpBQ,EAAQ,SAAC,GAAD,IAAGC,EAAH,EAAGA,KAAML,EAAT,EAASA,IAAKM,EAAd,EAAcA,IAAKJ,EAAnB,EAAmBA,KAAMK,EAAzB,EAAyBA,QAAzB,OAAuC,kBAACN,EAAD,CAAsBC,KAAMA,GAC/E,2BAAIG,GACJ,kBAACP,EAAD,CAAaS,QAASA,EAASP,IAAKA,EAAKM,IAAKA,MAGhDF,EAAMI,aAAe,CACnBN,KAAM,GACNG,KAAM,GACNL,IAAK,GACLM,IAAK,GACLC,QAAS,kBAAM,OAEFH,QCJPxB,EAAQC,EAyCD4B,EAvCH,WAAO,IAAD,EACUC,mBAAS,MADnB,mBACTC,EADS,KACFC,EADE,OAEQF,mBAAS,MAFjB,mBAETG,EAFS,KAEHC,EAFG,KAGVC,EAAUC,iBAAO,MAIjBC,EAASC,sBAAW,uCAAC,WAAOnC,GAAP,mBAAAC,EAAA,6DACzBD,EAAgBA,EAAcoC,MAAM,EAAG,GAAGC,KAAI,SAAAC,GAAI,OAAIC,OAAOC,OAAOF,EAAM,CACxEG,QAAQ,GAAD,OAAKC,IAAIC,gBAAgBL,IAChCrB,IAAKqB,EAAKM,UAHa,SAKM7C,EAAUC,GALhB,gBAKjB4B,EALiB,EAKjBA,MAAOE,EALU,EAKVA,KACfD,EAAS,GAAD,OAAIhC,EAAJ,YAAW+B,IACnBG,EAAQ,GAAD,OAAIlC,EAAJ,YAAWiC,IAPO,2CAAD,sDAQvB,IAfa,EAiBwBe,YAAY,CAAEX,WAA9CY,EAjBQ,EAiBRA,aAAcC,EAjBN,EAiBMA,cAEtB,OACE,kBAACpC,EAAD,KACE,kBAACG,EAAD,KACE,kBAAC,EAAD,CACEQ,KAAK,gHACLL,IAAKW,EACLL,IAAI,QACJJ,KAAK,QACLK,QAtBe,kBAAMQ,EAAQgB,QAAQC,WAwBvC,kBAAC,EAAD,CAAO3B,KAAK,iCAAQL,IAAKa,EAAMP,IAAI,UAGrC,kBAACH,EAAD,iBAAmB0B,IAAnB,CAAmCI,IAAKlB,IACtC,0BAAWe,QClCCI,QACW,cAA7BC,OAAOC,SAASC,UAEe,UAA7BF,OAAOC,SAASC,UAEhBF,OAAOC,SAASC,SAASC,MACvB,2DCbNC,IAASC,OAAO,kBAAC,EAAD,MAASC,SAASC,eAAe,SD4H3C,kBAAmBC,WACrBA,UAAUC,cAAcC,MAAMC,MAAK,SAAAC,GACjCA,EAAaC,kB","file":"static/js/main.e36cf6ba.chunk.js","sourcesContent":["export default {\n  url: 'https://8e87c81c.ngrok.io',\n}\n","import axios from 'axios';\nimport config from '../config';\n\nconst { url } = config;\n\nexport const getImages = async (acceptedFiles) => {\n  try {\n    const data = new FormData();\n    data.append('image', acceptedFiles[0]);\n    const { data: res } = await axios({\n      method: 'post',\n      url,\n      data,\n      config: { headers: { 'Content-Type': 'multipart/form-data' } }\n    });\n    return res;\n  }\n  catch (e) {\n    console.log('error', e);\n    return {};\n  }\n};\n","import styled from 'styled-components';\n\nexport const ParentContainer = styled.div`\n  position: fixed; \n  top: 0; \n  left: 0; \n  min-width: 100%;\n  min-height: 100%;\n  width: 100%;\n  height: 100%;\n`;\n\nexport const ImageContainer = styled.div`\n  display: flex;\n  justify-content: center;\n  align-items: center;\n  width: inherit;\n  height: inherit;\n`;\n\nexport const StyledImage = styled.img`\n  opacity: ${({src}) => src ? 1 : 0.5 };\n  border: ${({src}) => src ? 'none' : 'dashed black 1px'};\n  cursor: pointer;\n  height: auto;\n  width: 300px;\n  line-height: 250px;\n  text-align: center;\n`;\n\nexport const StyledImageContainer = styled.div`\n  display: flex;\n  flex-direction: column;\n  align-items: center;\n  margin-right: ${({text}) => text === 'Input' ? '20px' : 0 };\n\n`;\n\nexport const StyledContent = styled.div`\n  display: none;\n`;","import React from 'react';\nimport { StyledImage, StyledImageContainer } from '../App/styles';\n\nconst Image = ({ name, src, alt, text, onClick }) => <StyledImageContainer text={text}>\n  <p>{name}</p>\n  <StyledImage onClick={onClick} src={src} alt={alt}/>\n</StyledImageContainer>;\n\nImage.defaultProps = {\n  text: '',\n  name: '',\n  src: '',\n  alt: '',\n  onClick: () => null,\n}\nexport default Image","import React, { useCallback, useState, useRef } from 'react';\nimport { useDropzone } from 'react-dropzone';\nimport { getImages } from '../../api';\nimport config from '../../config';\nimport {\n  ImageContainer,\n  ParentContainer,\n  StyledContent,\n} from './styles';\nimport Image from '../Image';\n\nconst { url } = config;\n\nconst App = () => {\n  const [image, setImage] = useState(null);\n  const [mask, setMask] = useState(null);\n  const dropRef = useRef(null);\n\n  const onClickPicture = () => dropRef.current.click();\n\n  const onDrop = useCallback(async (acceptedFiles) => {\n    acceptedFiles = acceptedFiles.slice(0, 1).map(file => Object.assign(file, {\n      preview: `${URL.createObjectURL(file)}`,\n      src: file.path,\n    }));\n    const { image, mask } =  await getImages(acceptedFiles);\n    setImage(`${url}/${image}`);\n    setMask(`${url}/${mask}`);\n  }, []);\n\n  const { getRootProps, getInputProps } = useDropzone({ onDrop });\n\n  return (\n    <ParentContainer>\n      <ImageContainer>\n        <Image\n          name='Входное изображение'\n          src={image}\n          alt='Input'\n          text='Input'\n          onClick={onClickPicture}\n        />\n        <Image name='Маска' src={mask} alt='Mask' />\n      </ImageContainer>\n\n      <StyledContent {...getRootProps()} ref={dropRef}>\n        <input {...getInputProps()} />\n      </StyledContent>\n    </ParentContainer>\n  )\n};\n\nexport default App;","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.1/8 is considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl)\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport App from './components/App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}